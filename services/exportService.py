from fastapi import FastAPI, Request
from fastapi.templating import Jinja2Templates
import json
import io
from pyppeteer import launch
from fastapi import Request, HTTPException

templates = Jinja2Templates(directory="templates")
import traceback



async def render_pdf_with_puppeteer(html_content: str):
    try:
        print("Launching headless browser...")
        # Launch a headless browser
        chromium_executable_path = "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"
        browser = await launch(headless=True, executablePath=chromium_executable_path, args=['--no-sandbox'])
        print("Browser launched.")

        page = await browser.newPage()
        print("New page created.")

        # Load the rendered HTML
        print("Setting page content...")
        await page.setContent(html_content)

        # Wait for the JavaScript chart or any specific element to load
        # Example: Wait for an element with a class "chart-container" to appear
        print("Waiting for chart to load...")
        page.waitForSelector('body', {'timeout': 90000})        
        await page.waitForFunction('document.readyState === "complete"')
        print("Chart loaded.")

        # Generate the PDF
        print("Generating PDF...")
        pdf_file = await page.pdf({
            'width': '508mm',  # PowerPoint width in mm
            'height': '286mm',  # PowerPoint height in mm
            'printBackground': True,
            'margin': {'top': '2mm', 'bottom': '2mm', 'left': '2mm', 'right': '2mm'},
        })
        print("PDF generated.")

        await browser.close()
        print("Browser closed.")
        return pdf_file

    except Exception as e:
        # Log the error and the traceback for debugging
        print(f"Error occurred: {e}")
        print("Traceback:")
        traceback.print_exc()

        # Optionally, raise the error to propagate it further
        raise Exception("An error occurred while generating the PDF with Puppeteer.")




async def dashboard_pdf(request: Request):
    try:
        print("Loading data from multiple JSON files...")
        # Define the list of JSON files
        json_files = [
            "anomaly_detection.json",
            "descriptive_dashboard_output.json",
            "diagnostic_analysis.json",
            "predictive_dashboard_output.json",
            "prescriptive_analysis.json"
        ]

        # Load data from all JSON files into a dictionary
        # Merge all JSON data into a single dictionary
        combined_data = {}
        for file in json_files:
            try:
                with open(file) as f:
                    file_data = json.load(f)
                    # Store the data and filename under the key
                    key_name = file.replace(".json", "")  # e.g., "anomaly_detection"
                    combined_data[key_name] =file_data
                    print(f"Data from {file} added under '{key_name}' key.")
            except FileNotFoundError:
                print(f"Warning: {file} not found, skipping.")
            except json.JSONDecodeError as e:
                print(f"Error decoding {file}: {e}, skipping.")


        # print("All data loaded successfully.",combined_data)

        # Render HTML template with combined data
        print("Rendering HTML template with data...")
        template_response = templates.TemplateResponse(
            "chart.html",
            {"request": request, "data": combined_data}
        )
        print("HTML template rendered.")

        # Fetch the HTML content generated by TemplateResponse
        rendered_html = template_response.body.decode('utf-8')
        print("HTML content generated.")

        # Generate PDF using Puppeteer
        print("Calling render_pdf_with_puppeteer...")
        pdf_file = await render_pdf_with_puppeteer(rendered_html)
        print("PDF file generated.")

        # Return the PDF file as a BytesIO object
        print("Returning PDF as BytesIO...")
        return io.BytesIO(pdf_file)
    except Exception as e:
        # Log the error and traceback for debugging
        print(f"Error occurred: {e}")
        print("Traceback:")
        traceback.print_exc()

        # Raise an HTTPException for a proper error response
        raise HTTPException(status_code=500, detail="Internal Server Error")